class NEW_T ITERATOR(SIZE? CONST size) extends NEW_T NEXTABLE
    ===
    Returns the next value of the iterator, or null
    if the iterator is finished:
    ===
    NEW_T? MD next();

    class LAMBDA(
        ===
        function which gets the next value of the iterator, or null
        if the iterator is finished:
        ===
        NEW_T? FN new.next__()

        ===
        value which provides the total number of elements which will
        be iterated over, if available.  if there is a backing container,
        this is the original number of elements in the container.
        ===
        SIZE? CONST new.size
    ) extends NEW_T ITERATOR(new.size)
        NEW_T? MD next() = new.next()

    ===
    standard map and filter all in one.
    the callback should return a null if the `NEW_U` instance
    should not be produced in the new iterator.
    ===
    NEW_U ITERATOR MD map(NEW_U? FN(NEW_T)) = LAMBDA(
        # TODO: support other things besides `next()`:
        NEW_U? FN new.next()
            NEW_T? current
            while (current = next()) != null
                newUQ = fn(current)
                if newUQ, return newUQ.move()
            return null
    )
    # TODO: add map overload with a non-null NEW_U return value, so that we can
    # add the known size as well.

    ===
    An abstract class for an iterator which defines a `peak()` method, which allows
    users to see the next value in the iteration without changing the iterator.
    ===
    class PEAKABLE(SIZE? CONST size)
            extends NEW_T :interfaces.PEAKABLE, NEW_T ITERATOR(size);

    class NEW_T BUFFERED extends NEW_T ITERATOR.PEAKABLE
        NEW_T? currentValue__

        from(NEW_T ITERATOR this.old__)
            ITERATOR.PEAKABLE.from(this.old.size)
            currentValue = this.old.next()

        CONST_NEW_T REF? MD peak()
            return currentValue

        NEW_T? MD next()
            if currentValue != null
                # TODO: nim-style a = b = c style moves.
                newTQ = currentValue = old.next()

    ===
    An abstract class for an iterator which defines a `remove()` method, which allow users
    to remove the next value in the iteration, which changes the iterator and underlying
    container.
    ===
    class NEW_T REMOVABLE extends NEW_T :interfaces.REMOVABLE, NEW_T ITERATOR
        pass

    ===
    An abstract class for an iterator which defines `peak()` and `remove()` methods,
    which allow users to see the next value in the iteration without changing the iterator,
    as well as remove the next value in the iteration (which does change the iterator and
    the underlying container).
    ===
    # TODO: better way to annotate interfaces.  e.g. extends NEW_T ITERATOR & PEAKABLE & REMOVABLE
    class NEW_T PEAKABLE_REMOVABLE extends
            NEW_T :interfaces.PEAKABLE,
            NEW_T :interfaces.REMOVABLE,
            NEW_T ITERATOR
        ===
        Takes elements from this `ITERATOR` and puts them into a new one,
        based on some filtering criterion.
        ```
        INT ARRAY x = [1, 2, 3, 100, 9, 11]
        INT ARRAY y = x.take($whereValue < 10)
        # y == [1, 2, 3, 9]
        # x == [100, 11]
        ```
        ===
        NEW_T ITERATOR MD take(BOOL FN(CONST_NEW_T REF whereValue)) = ITERATOR.LAMBDA(
            NEW_T? FN new.next()
                CONST_NEW_T REF? peaked
                while (peaked = peak()) != null
                    if fn(WhereValue(peaked))
                        return remove()
                    next()
                return null
        )
