class newT array extends NewT IndexedContainer
    # TODO: this doesn't work if the array elements are more complicated types:
    # e.g.
    #   Int Array array Nested
    #   Nested[0].append(5)
    #   print Nested[0]     # will print empty array [] instead of [5]
    # TODO: maybe make get(), ref(), set(), swap()
    class arrayGrsv__(Index, NewT Array constRef Array__) extends NewT Grsv
        NewT get()
            return Array.get(Index)
        NewT remove()
            return Array.remove(Index)
        NewT swap(newT New)
            return Array.swap(Index, New)
        # TODO: use `view` type here instead of `ConstType ref`
        ConstNewT Ref view()
            # TODO: try to condense `get` and `view` into a single method on the array.
            return Array.view(Index)

    NewT Grsv This(Index) = arrayGrsv(Index, Array(This))

    class valueIterator_(
        NewT Array constRef Array__
    ) extends NewT iterator.IPR(Array.size())
        Index __ = 0

        NewT? next()
            return Array.get(Index++) if Index < Array.size() else Null

        insert(NewT)
            if Index < Array.size()
                Array.insert(Index++, NewT)
            else
                Array.append(NewT)
                Index = Array.size()

        ConstNewT Ref? peak()
            return Array.view(Index) if Index < Array.size() else Null

        NewT? remove()
            return Array.remove(Index) if Index < Array.size() else Null

    # TODO: maybe try to kill off const stuff.  it's confusing in C++, and it's not pretty here either.
    # the benefit of const helps with some optimizations, e.g., thread-safety for multiple read-only ok.
    # but you're still going to need mutexes and stuff to avoid other threads writing to an object.
    class constValueIterator_(
        NewT Array Ref const Array__
    ) extends ConstNewT Ref iterator.P(Array.size())
        Index __ = 0

        ConstNewT Ref? next()
            return Array.view(Index++) if Index < Array.size() else Null

        # TODO: double check:
        ConstNewT Ref Const Ref? peak()
            return Array.view(Index) if Index < Array.size() else Null

    class newT indexIterator_(
        NewT Array constRef Array__
    ) extends [Index, NewT] Iterator(Array.size())
        index NextIndex__ = 0

        [Index, NewT]? next()
            if NextIndex >= Array.size()
                return Null
            Index = NextIndex++
            NewT = Array.get(Index)

    # TODO: define indexIterator without peak, but on const view of the array and on ref of NewT

    # TODO: make these automatic based on VALUE_iterator's hierarchy:
    to NewT iterator.IPR = valueIterator(Array(This))
    to NewT iterator.PR = valueIterator(Array(This))
    to NewT iterator.P = valueIterator(Array(This))
    to NewT iterator.R = valueIterator(Array(This))
    to NewT iterator = valueIterator(Array(This))

    to [Index, NewT] iterator = indexIterator(Array(This))

