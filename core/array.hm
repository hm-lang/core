@include(<vector>)

array~t := extend(indexable) {
    @private
    Allocation; allocation

    # TODO: convert this into a deque, add `Start: count`

    @private
    Count; count = 0

    ::count() := This Count
    ;;count(Count): 
        assert Count >= 0
        if Count == This Count
            return
        if Count > This Count
            This allocate(Count)
            while This Count < Count
                Allocation defaultConstruct(This Count++)
        else
            while This Count > Count
                Allocation deconstruct(--This Count)

    @private
    ;;allocate(Count): null
        assert Count >= 0
        if DesiredAllocation < 0
            throw error("cannot allocate +$(Delta) from $(This Count): overflow")
        if DesiredAllocation <= Allocation Count
            return

        # we should at least try to double the storage
        TryToAllocate ;= This roughlyDoubleAllocation()
        if DesiredAllocation >= TryToAllocate
            Allocation count(DesiredAllocation)
            return

        while True
            try
                Allocation count(TryToAllocate)
            except
                TryToAllocate = (TryToAllocate + DesiredAllocation) // 2

    ;;append(T): null
        debug->assert This Count < count::Max
        This allocate(This Count + 1)
        Allocation copyConstruct(This Count++, T)

    ;;append(T;): null
        debug->assert This Count < count::Max
        This allocate(This Count + 1)
        Allocation moveConstruct(This Count++, T;)

    ::[Index]?: t
        PositiveIndex := This ensurePositive(@hide Index)
        if PositiveIndex >= This count()
            Null
        else
            This[InBounds: PositiveIndex]

    # getter
    ;;[Index]: t
        PositiveIndex := This ensurePositive(@hide Index)
        if PositiveIndex >= This count()
            This count(PositiveIndex + 1)
        This[InBounds: PositiveIndex]
   
    # in-bounds getter, which is unsafe to call unless `InBounds` is 
    # within the range `[0, This count())`.
    ::[InBounds]: t
        debug->assert InBounds < This count()
        Allocation[InBounds]

    # no-copy getter/setter; it can resize the array to return a value.
    ;;[Index, fn(T;:): ~u]: u
        PositiveIndex := This ensurePositive(@hide Index)
        if PositiveIndex >= This count()
            This count(PositiveIndex + 1)
        This[InBounds: PositiveIndex, fn]

    # no-copy getter/setter which is unsafe to call unless `InBounds`
    # is within the range `[0, This count())`.
    ;;[InBounds, fn(T;:): ~u]: u
        debug->assert InBounds < This count()
        Allocation[InBounds, fn]
   
    # no-copy getter that keeps
    ::[Index, fn(T?): u]: u
        debug->assert InBounds < This count()
        Allocation[InBounds]

    # returns a non-null value of the array element at the specified index,
    # or the end of the array if not specified.  throws an error if the element
    # would be out of bounds (e.g., `Index >= This count()` or no elements present).
    ;;pop(Index = -1): t
        This pop(This inBounds(Index))

    ;;pop(InBounds): t
        Result := This[InBounds: Index]!
        This erase(InBounds)
        Result

    ;;erase(Index): null
        This erase(This inBounds(Index))

    ;;erase(InBounds): null
        debug->assert InBounds >= 0 and InBounds < This count()
        for DestinationIndex := InBounds, DestinationIndex < This count() - 1
            This[DestinationIndex] = This[DestinationIndex + 1]!
        This count(This count() - 1)

    ::!!This: bool
        return This count() > 0

    # getter, which passes a Null into the callback if index is out of bounds in the array:
    ::[Index, fn(T?): ~u]: u

    # moves the value at Index into the return value if Index is within the size of the array,
    # resetting the array element to a default `t()` if so.
    # otherwise, returns Null if Index was too big and doesn't reset any array elements.
    ;;[Index]!?: t
        InBounds := This tryToBePositive(@hide Index)
        if InBounds < 0 or InBounds >= This count()
            return Null
        return This[InBounds: Index]!

    # moves the value at Index into the return value if Index is within the size of the array,
    # resetting the array element to a default `t()` if so.
    # otherwise, throws an out-of-bounds error.
    ;;[Index]!: t
        return This moot(This inBounds(Index))

    @private
    # returns the value at Index, resetting the array elements value to a default value.
    ;;mootInBounds(Index): t
        debug->assert Index >= 0 and Index < This count()
        T; t
        @cc{
            hm(T) = std::move(Internal[hm(Index)]);
            Internal[hm(Index)] = hm(t)();
        }
        return T!

    # swapper, sets the value at the index, returning the old value in the reference.
    # if the swapped in value is Null but the array value wasn't Null, the array
    # will shrink by one, and all later indexed values will move down one index.
    ;;swap(Index;, @@T?): null
        This tryToBePositive(@@Index)
        if T == Null
            T = pop(Index)
        else
            New->T ?:= This[Index]!
            This[Index] = T!
            T = New->T!

    ;;[Index, @@T?] := swap(Index, @@T)

    # allows access to modify the nullable internal value via MMR (`@@`).
    # passes the current value at the index into the passed-in modifier function.
    # if Index >= the current This count(), a Null is passed into the modifier.
    # if the modifier changes T from Null to a non-null instance, but Index was too large,
    # then the array size is increased (to Index + 1) and filled with default values up
    # to Index, then set to the new value determined by the modifier.
    # if the modifier switches T from non-null to Null, then the array will shrink
    # by one and all later indexed values move down one.
    ;;modify(Index;, fn(@@T?): ~u): u
        This ensurePositive(@@Index)
        T?; t = This[Index]!
        Result := fn(@@T)
        if T != Null
            This[Index] = T!
        else
            pop(Index)
        return Result

    ;;[Index, fn(@@T?): ~u] := modify(Index, fn)

    # allows access to modify the internal value via MMR (`@@`).
    # passes the current value at the index into the passed-in modifier function.
    # if Index >= the current This count(), then the array size is increased (to Index + 1)
    # and filled with default values so that a non-null instance can be passed into the modifier.
    ;;modify(Index, fn(@@T): ~u): u
        This ensurePositive(@@Index)
        if Index >= This count()
            This count(Index + 1)
        T; t = This[Index]!
        Result := fn(@@T)
        This[Index] = T!
        return Result

    ;;[Index, fn(@@T): ~u] := modify(Index, fn)

    # returns a copy of this array, but sorted:
    ::sort(): this

    # sorts this array in place:
    ;;sort(): null

    @private
    ::tryToBePositive(Index) := if Index < 0
        Index + This count()
    else
        Index

    @private
    ::ensurePositive(Incoming->Index): index
        Index := This tryToBePositive(Incoming->Index)
        assert Index >= 0
            "Index $(Incoming->Index) was invalid"
        Index

    @private
    ::inBounds(Incoming->Index): inBounds
        Index := This tryToBePositive(Incoming->Index)
        assert Index >= 0 and Index < count()
            "Index $(Incoming->Index) was invalid"
        inBounds(Index)

    @private
    ::roughlyDoubleAllocation(): count
        if This Allocation Count == 0
            return 4
        Doubled := 2 * This Allocation Count
        if Doubled >= 0
            return Doubled
        # if we're at this point, we're in insane territory
}
