# TODO: can we define the grammar in the terms below, but then create a finite state machine
# which reads in the grammar below, deduces the possible states, then reads tokens in and
# flips between states while reading through files?

# list of elements that can compose the grammar.
# doesn't include tokens like `LowerCamelCase` or `UpperCamelCase`,
# which comprise the grammar but don't specify it.
grammarElement: oneOf[
    Statement: oneOf[
        VariableDefinition
        VariableDeclaration
        FunctionDefinition
        FunctionDeclaration
        ClassDeclaration
        Expression
    ]
    Expression: {
        token PrefixUnaryOperator?
        oneOf[BinaryExpression, Number, Array[nestable]]
        token PostfixUnaryOperator?
    }
    BinaryExpression: {
        token BinaryOperator
        LeftOperand: expression
        RightOperand: expression
    }
    Nestable: oneOf[FunctionCall, ClassName, VariableName]

    Type: oneOf[PlainType, VariableDeclaration, FunctionDeclaration]

    # e.g., `myClass` or `genericClass[type1, ...]`
    PlainType: {ClassName, GenericSpecification?}
    # e.g., `MyClass` or `GenericClass[type1, ...]` for a type that's in scope
    DefaultNamedVariable: {DefaultClassName, GenericSpecification?}

    # e.g., `[x, y: constraintY, Z: zType]`
    # to be valid, `x` should not be in scope.
    GenericDeclaration: array[ArgumentDeclaration]
    # e.g., `[x, y: int, Z: 5]`
    # to be valid, `x` *should* be in scope.
    GenericSpecification: array[ArgumentDefinition]

    VariableName: token UpperCamelCase
    VariableDeclaration: oneOf[StandardVariableDeclaration, AbbreviatedVariableDeclaration]
    StandardVariableDeclaration: {VariableName, token Declaration, PlainType}
    AbbreviatedVariableDeclaration: {DefaultNamedVariable, token Declaration?}

    VariableDefinition: oneOf[StandardVariableDefinition, AbbreviatedVariableDefinition]
    StandardVariableDefinition: {VariableName, token Declaration, Expression}
    AbbreviatedVariableDefinition: {DefaultNamedVariable, token Declaration, Expression}

    FunctionName
    FunctionArgsWithReturnType
    # e.g., `myFn(Arg1, Arg2): type` or `fn[type1](Arg1, Arg2): type`
    # can be used as a `Type` when returning a function from another function.
    FunctionDeclaration
    FunctionDefinition
    FunctionCall

    ArgumentDeclaration
    ArgumentDefinition

    RhsStatement
    AtomicStatement

    ClassName: token LowerCamelCase
    DefaultClassName: token UpperCamelCase
    ClassDefinition
    ClassStatement
    ClassMethod

    ForLoop

    EndOfInput
]
# TODO: `grammarElement`s probably should be POD structs, e.g., `Type: {Array[Token]}`
# however, it's probably better to give them more individualized types, like
# `Type: oneOf[PlainType: {Name: str, Generics?}, FunctionDeclaration: {...}]`

Grammar: {
    element: grammarElement
    statement: grammarElement statement
    parsed: array[statement] {
        ::hm(): array[str]
            # TODO!
            []
        ::execute(Interpreter;): hm[ok: any, uh: str]
            # TODO
            uh("not implemented")
    }
    uh: {
        BadLine: index
        Error: str
        Parsed
    }
    hm[of]: hm[ok: of, uh]
    result: hm[parsed]

    ::parse(File): result
        Context;
        I parse(File, Context;)

    ::parse(File, Context;): result
        Proposals;
        what I parse(File read(), Context, Proposals;)
            Parsed:
                File write(Parsed hm())
                Context commit(Proposals)
            Uh:
                error("on line $(Uh BadLine + 1):")
                if Uh BadLine > 0
                    error(". $(Lines[Uh BadLine - 1]")
                error("> $(Lines[Uh BadLine]")
                error("? $(Uh Error)")
                File open("w", (Handle):
                    for Index; < Lines count()
                        Handle write(Lines[Index])
                        if Index == Uh BadLine
                            Handle write(Uh Error)
                )

    ::parse(Array[str]., Context;): result
        Proposals;
        I parse(Array!, Context, Proposals;) check((Ok):
            Context commit(Proposals!)
        )
    
    @private
    ::parse(Array[str]., Context, Proposals;): result
        # TODO: can we do `Tokenizer(...);` to define `Tokenizer: tokenizer(...)`?
        Tokenizer; tokenizer(Array!)

        Parsed;
        for Index; < Array count()
            # TODO: Tokens should be retrieved as needed
            #       probably need a `Tokenizer; {LineIndex: index, ColumnIndex: index, Array[str]}`
            #       class which has some methods like `next()`
            Tokens: tokenize(Array[Index], Context, Proposals) map((Uh):
                {BadLine: Index, Error: Uh, Parsed!}
            ) assert()
            Parsed append(I parse(Tokens, Context, Proposals;) map((Uh):
                {BadLine: Index, Error: Uh, Parsed!}
            ) assert())
        Parsed

    @protected
    ::parse(Array[token], Context, Proposals;): 

    @private
    Lot[at: element, tokenMatcher]: [
        Type: oneOfMatcher([
            FunctionDeclaration
            PlainType
        ])
        PlainType: sequenceMatcher([
            LowerCamelCase
            optionalMatcher(GenericsList)
        ])

        VariableName: singleTokenMatcher(UpperCamelCase)
        VariableDeclaration: sequenceMatcher([
            VariableName
            optionalMatcher(operatorMatcher("?"))
            oneOfMatcher([operatorMatcher(":"), operatorMatcher(";")])
            TypeElement
        ])
        VariableDefinition: sequenceMatcher([
            VariableName
            optionalMatcher(operatorMatcher("?"))
            oneOfMatcher([operatorMatcher(":"), operatorMatcher(";")])
            RhsStatement
        ])

        FunctionName: singleTokenMatcher(LowerCamelCase)
        FunctionDeclaration: oneOfMatcher([
            # `fnName(Args): retType`, `fnName?(Args): retType`, or
            # `fnName(Args)?: retType`, also allowing `;` instead of `:`.
            sequenceMatcher([
                FunctionName
                FunctionArgsWithReturnType
            ])
            # `fnName: fn(Args): retType` or similar
            sequenceMatcher([
                FunctionName
                oneOfMatcher([operatorMatcher(":"), operatorMatcher(";")])
                FunctionType
            ])
        ])
        FunctionArgsWithReturnType: sequenceMatcher([
            listMatcher(FunctionArgument)
            optionalMatcher(operatorMatcher("?"))
            oneOfMatcher([operatorMatcher(":"), operatorMatcher(";")])
            TypeElement
        ])
        FunctionDefinition: oneOfMatcher([
            # fnName(Args...): returnType
            #   BlockStatements
            sequenceMatcher([FunctionDeclaration, Block])
            # (Args...): returnType
            #   BlockStatements
            sequenceMatcher([FunctionArgsWithReturnType, Block])
            # fnName(Args...): Statement
            sequenceMatcher([
                FunctionName 
                FunctionArgsWithReturnType
                RhsStatement
            ])
            # (Args...): Statement
            sequenceMatcher([
                FunctionArgsWithReturnType
                RhsStatement
            ])
        ])
        FunctionArgument: oneOfMatcher([
            VariableDefinition
            VariableDeclaration
            FunctionDefinition
            FunctionDeclaration
        ])
        FunctionCall: sequenceMatcher([FunctionName, AtomicStatement])
        # TODO: templates, or maybe preprocess these into lowerCamelCase types with hooks
        FunctionType: sequenceMatcher([
            optionalMatcher(identifierMatcher("fn"))
            optionalMatcher(GenericsList)
            FunctionArgsWithReturnType
        ])
        RhsStatement: oneOfMatcher([
            AtomicStatement,
            sequenceMatcher([AtomicStatement, AnyOperator, RhsStatement]),
        ])
        AtomicStatement: oneOfMatcher([
            VariableName
            FunctionCall
            parenthesesMatcher(RhsStatement)
            listMatcher(DefinedArgument)
        ])
        ClassName: sequenceMatcher([
            LowerCamelCase
            optionalMatcher(TemplateArguments)
        ])
        ExtendParentClasses: sequenceMatcher([
            keywordMatcher("extend")
            listMatcher(ClassName)
        ])
        ClassDefinition: sequenceMatcher([
            ClassName
            oneOfMatcher([
                operatorMatcher(":")
                doNotAllow(operatorMatcher(";"), "Classes cannot be writable.")
                doNotAllow(operatorMatcher("?;"), "Classes cannot be nullable/writable.")
                doNotAllow(operatorMatcher("?:"), "Classes cannot be nullable.")
            ])
            optionalMatcher(ExtendParentClasses)
            parenthesesMatcher(repeatMatcher([ClassStatement], Until: operatorMatcher("}")))
        ])
        ClassStatement: oneOfMatcher([
            VariableDefinition
            VariableDeclaration
            FunctionDefinition
            FunctionDeclaration
            ClassMethod
        ])
        ClassMethod: sequenceMatcher([
            oneOfMatcher([
                operatorMatcher("::")
                operatorMatcher(";;")
                operatorMatcher(";:")
                operatorMatcher(":;")
            ]),
            oneOfMatcher([
                FunctionDefinition
                FunctionDeclaration
                # TODO: prefix ! and !!, as well as postfix !
            ])
        ])

        #(#
        # for-loops
        # e.g.
        for Variable: variableType < UpperBoundExclusive
            ... use Variable from 0 to ceil(UpperBoundExclusive) - 1 ...
        # or
        for Variable: variableType <= UpperBoundInclusive
            ... use Variable from 0 to floor(UpperBoundInclusive) ...
        # TODO: support starting value, or just variable names
        Variable; variableType = 5
        for @lock Variable < UpperBoundExclusive
            ... use Variable from 0 to ceil(UpperBoundExclusive) - 1 ...
        # starting at number in the for loop
        for Variable: StartingValue, Variable < UpperBoundExclusive
            ... use Variable from StartingValue ...
        #)#
        ForLoop: oneOfMatcher([
            sequenceMatcher([
                # TODO: do we even need `keywordMatcher`, `identifierMatcher`, and `operatorMatcher`?
                #       can't we just use `singleTokenMatcher` and be done with it?
                keywordMatcher("for")
                VariableDeclaration
                oneOfMatcher([operatorMatcher("<"), operatorMatcher("<=")])
                Expression
                Block
            ])
            sequenceMatcher([
                keywordMatcher("for")
                listMatcher(FunctionArgument)
                keywordMatcher("in")
                Expression
                Block
            ])
        ])

        EndOfInput: tokenMatcher(
            ::match(Index;, Array[token]): Index >= Array count()
        )
    ]

    ::match(Index;, Array[token], GrammarMatcher): bool
        # ensure being able to restore the current token index if we don't match:
        Snapshot: Index
        Matched: what GrammarMatcher
            (TokenMatcher):
                TokenMatcher match(Index;, Array)
            (GrammerElement):
                My Lot[GrammarElement] match(Index;, Array)
            (Token):
                Index < Array count() and Array[Index++] == Token
        if not Matched
            Index = Snapshot
        return Matched
}()

singleTokenMatcher: tokenMatcher (
    ;;renew(My Token): Null

    # we automatically inherit the @visibility of the parent class method
    # unless we specifically provide one.
    ;;match(Index;, Array[token]): bool
        return Index < Array count() and Array[Index++] == My Token
)

# TODO: actually compiling code will require going through the TokenMatchers
# in a specific order to avoid running through all options to see what fits.
# OR, maybe we can parse a statement into tokens, and then do a `what Statement`
# with case `RhsStatement` etc., where the hash only takes into account the sequence
# of tokens but not the actual token content.  we'd also need to ignore repeated fields,
# i.e., only count them once.
# TODO: support for labeling token matchers, e.g. "parentClassNames" and "classBlock"
# or probably don't need to label token matchers if we build the logic for transpilation
# inside of the grammar elements.

# a list encompasses things like (), (GrammarMatcher), (GrammarMatcher, GrammarMatcher), etc.,
# but also lists with newlines if properly tabbed.
listMatcher(GrammarMatcher): parenthesesMatcher(repeatMatcher([
    GrammarMatcher
    CommaOrBlockNewline
])

sequence: tokenMatcher {
    ;;renew(My Array; grammarMatcher[]): Null

    ::match(Index;, ToMatch Array[token]): bool
        for GrammarMatcher: in My Array
            if not Grammar match(Index;, ToMatch Array, GrammarMatcher)
                return False
        return True
}

# TODO: add an argument to parentheses matcher for the type of parentheses, e.g., () [] {}
# TODO: make `block` a type of token as well.
parenthesesMatcher: tokenMatcher {
    ;;renew(My GrammarMatcher): Null

    ::match(Index;, Array[token]): bool
        CurrentToken: Array[Index]
        if currentToken != parenthesesToken
            return False

        InternalIndex; index = 0
        PartialMatch: Grammar match(InternalIndex;, CurrentToken InternalTokens, My GrammarMatcher)
        if not PartialMatch
            return False

        # need to ensure that the full content was matched inside the parentheses:
        if InternalIndex < CurrentToken InternalTokens count()
            return False
        
        ++Index
        return True
}

# TODO: make this a function which returns either `repeatInterruptible` and `repeatTimes`
# this is essentially the definition for repeatInterruptible:
repeatMatcher: tokenMatcher {
    # until `Until` is found, checks matches through `Array` repeatedly.
    # note that `Until` can be found at any point in the array;
    # i.e., breaking out of the array early (after finding `Until`) still counts as a match.
    # if you need to ensure a non-breakable sequence is found before `Until`,
    # use the `sequence` token matcher inside `Array`.
    i(My Until: GrammarMatcher = EndOfInput, My Array: GrammarMatcher[]): i()
    ;;renew(My Until: GrammarMatcher = EndOfInput, My Array[grammarMatcher]): Null

    ::match(Index;, ToMatch Array[token]): bool
        if Index >= Array count()
            return False

        while True
            # TODO: is there a better syntax here that doesn't put `X: x` in front of `in`?
            #       it'd be nice to avoid parentheses if necessary, although that does make it clear
            #       that we have reference-like abilities.
            #       maybe `in My Array, GrammarMatcher:` or `iterate My Array, GrammarMatcher:`
            #           or `with My Array, GrammarMatcher:`
            #       or `for GrammarMatcher:, in My Array`
            for GrammarMatcher: in My Array
                # always check the escape sequence, Until:
                if Grammar match(Index;, ToMatch Array, My Until)
                    return True
                # note that it's ok to call `Grammar` here despite
                # the self-referential nature of the grammar, because
                # this logic would essentially be written in a .cc file
                # whereas `Grammar` would be defined in the .h file.
                if not Grammar match(Index;, GrammarMatcher)
                    return False
}
