uh: oneOf[
    DidNotFinishMidLineComment: str
    AmbiguousOperator: str
]
hm[of]: hm[ok: of, uh]

tokenizer: {
    @private {
        Lines[str]          # lines to parse
        LineIndex; index    # current index into `Lines`
        CharIndex; index    # current index into `Lines[LineIndex]`
        Hm[token];          # current result
    }

    ;;reset(Array[str].): null
        My Lines = Array!
        # Do a little work here so we don't need to keep track of
        # whether we've initialized `My Token` for the first `peek`.
        My Token = My next()

    ::lineIndex(): My LineIndex

    ::peek(fn(Hm[token]): ~t): t
        fn(My Hm)

    ;;take(): token
        Result; My next()
        Result <-> My Hm
        Result orPanic()

    @private
    ;;next(): hm[token]
        if My LineIndex >= My Lines count()
            return EndOfFile
        while True
            Char: advanceChar()
            match Char
                0
                    ++My LineIndex
                    My CharIndex = 0
                    return NewLine
                ' ', '\t'
                    continue
                '"'
                    return I consumeString()
                '\''
                    return I consumeRune()
                '+', '-',
                    return I consumePlusMinusOperator(StartingChar: Char)
                '*', '/',
                    return I consumeBinaryOperator(StartingChar: Char)
                # TODO

    ;;advanceChar(): u8
        My Lines[My LineIndex][My CharIndex++, Default: 0]

    # if `+` will return that.
    # if `++` will return that.
    # if `+++` will return an error since we don't know if it's `+ ++` or `++ +`;
    # we could analyze tokens before/after to determine if it should be prefix/postfix
    # but we'll prefer users to make it clear in the code.
    @private
    ;;consumePlusMinusOperator(StartingChar: u8): hm[token]
        assert(My LineIndex < My Lines count())
        NextChar: My Lines[My LineIndex][My CharIndex + 1, Default: 0]
        if NextChar != StartingChar
            # just `+` or `-`:
            return operator(StartingChar)

        assert(I advanceChar() == NextChar)
        NextNextChar: My Lines[My LineIndex][My CharIndex + 1, Default: 0]
        if NextChar != NextNextChar
            # `++` or `--`:
            return operator(StartingChar | (StartingChar << 8))
        
        # +++ or ---.  this is ambiguous...
        return ambiguousOperator(I formatError("ambiguous operator, use `++ +` or `- --`"))

    @private
    ::formatError(Str): str
        Prefix; "#@!$"
        if My CharIndex >= Prefix count()
            Prefix[My CharIndex] = '^'
        Prefix + " " + Str 
}

token: oneOf[
    EndOfFile: 0

    # TODO: a `oneOf` already has some space for a tag.
    #       we could use one tag number for `smallStr` and another for `str`
    #       both could point to `LowerCamelCase` (or whatever) but a different data format.
    #       the `token` tag itself will probably fit into 1 byte so we could have up to
    #       7 + 8 = 15 bytes (on a 64-bit platform) for a short string.
    EndOfLineComment: str           # e.g., `# nothing gets passed you`
    MidLineComment: str             # e.g., `#( whatever )#`
    MultilineComment: array[str]    # e.g., `#(# ... #)#` with newlines

    CompilerComment: str    # e.g., `#salt(123)`
    CompilerError: str      # e.g., `#@!$...`

    LowerCamelCase: str
    UpperCamelCase: str

    Indent: i64     # number of spaces, always absolute: not relative from last indent
    Declaration: oneOf[Readonly: 1, Writable, Fleeting] {
        @alias Temporary: Fleeting
        @Null: 0
    }

    Comma
    NewLine

    Operator: n64   # e.g., `and`, `<=`, or `+` squished into 8 bytes,
                    # with higher bytes zeroed.

    Rune: i32   # something in single quotes, e.g., 'รถ' or '5'
    String: str # something in double quotes
    # TODO: add InterpolatedString

    Aside: array[token]     # e.g., `(...)`
    Brace: array[token]     # e.g., `{...}`
    Bracket: array[token]   # e.g., `[...]`

    LambdaAside: array[token]   # e.g., `$(...)`
    LambdaBrace: array[token]   # e.g., `${...}`
    LambdaBracket: array[token] # e.g., `$[...]`
] {
    @alias MultiLineComment: MultilineComment
}

n64: u64 {
    @Null: 0
}
