token: oneOf[
    # TODO: a `oneOf` already has some space for a tag.
    #       we could use one tag number for `smallStr` and another for `str`
    #       both could point to `LowerCamelCase` (or whatever) but a different data format.
    #       the `token` tag itself will probably fit into 1 byte so we could have up to
    #       7 + 8 = 15 bytes (on a 64-bit platform) for a short string.
    EndOfLineComment: str
    MidLineComment: str
    MultilineComment: array[str]

    CompilerComment: str
    CompilerWarning: str
    CompilerError: str  # e.g., `#@!$...`

    LowerCamelCase: str
    UpperCamelCase: str

    Indent: i64
    Declaration: oneOf[Readonly, Writable, Fleeting] {@alias Temporary: Fleeting}

    Comma
    BinaryOperator: u64         # e.g., `and`, `<=`, or `+` squished into 8 bytes,
                                # with higher bytes zeroed.
    PrefixUnaryOperator: u64    # e.g., `-` (without a corresponding left operand)
                                # or `++`, squished into 8 bytes.
    PostfixUnaryOperator: u64   # e.g., `?` or `--`, squished into 8 bytes.

    IndentedBlock: array[token],    # e.g., `$(...)`

    Rune: i32   # something in single quotes, e.g., 'รถ' or '5'
    String: str # something in double quotes
    # TODO: add InterpolatedString
] {
    @alias MultiLineComment: MultilineComment
}

statementToken: token {
    ;;reset(This Indent, This Tokens; tokens_): Null
}

statementTokenIterator: extend(iterator~statementToken) {
    ;;reset(@private This Lines!): Null

    ;;next()?: statementToken [*
        while (NextLine ?;= Lines next()) != Null
            StatementToken ?;= nextToken(NextLine! runes())
            if StatementToken != Null
                return StatementToken!
    ]

    # returns Null if this set of runes was just a "comment statement";
    # comments don't count as a statement of any kind.
    @private
    ;;nextToken(Runes!; iterator~rune, OverrideIndentSpaces?: index)?: statementToken [*
        SpaceCount; index = 0
        while (Rune ?:= Runes peak()) != Null {*
            consider Rune
                case ' '
                    Runes next()
                    ++SpaceCount
                case '#'
                    consumeComment(@@Runes)
                    return nextToken(
                        Runes!
                        OverrideIndentSpaces: OverrideIndentSpaces ?? SpaceCount
                    )
                default
                    return consumeStatement(@@Runes, OverrideIndentSpaces)
        }
        # an empty statement (without comments) always counts as indent 0:
        return {Indent: 0}
    ]

    @private
    ;;consumeComment(@@Runes; iterator~rune): null [*
        assert Runes->next() == '#'

        NextRune ;= Runes next()

        if NextRune == Null or not NextRune isOpenParenthesis()
            # ordinary EOL comment, remove everything to end of line:
            Runes reset()
            return

        OpenParenthesis: NextRune
        CloseParenthesis: OpenParenthesis toCloseParenthesis()

        assert (NextRune = Runes next()) != Null
            `expected ${CloseParenthesis}# before end of line
             OR another # to indicate a multiline comment, e.g., #${OpenParenthesis}#`

        if NextRune == '#'
            # TODO: consume multiline comment
            throw "unimplemented"

        # in-line comment, e.g., `#[` followed by `]#`
        if not Runes has(Sequence: [CloseParenthesis, '#'])
            throw "expected closing ${CloseParenthesis}# before end of line" 
    ]

    ;;consumeStatement(@@Runes; iterator~rune, OverrideIndentSpaces?: indent): statementToken [*
        throw "unimplemented"
    ]
}

indent: extend(u8) {
    ;;reset(SpaceCount: indent): null
        assert SpaceCount % 4 == 0
        assert SpaceCount / 4 <= 7
        ;;reset(u8(SpaceCount / 4))
}

@private
line: extend(string) {}
@private
lines: extend(iterator~line) {}
