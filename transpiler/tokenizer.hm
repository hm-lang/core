token: oneOf[
    # TODO: a `oneOf` already has some space for a tag.
    #       we could use one tag number for `smallStr` and another for `str`
    #       both could point to `LowerCamelCase` (or whatever) but a different data format.
    #       the `token` tag itself will probably fit into 1 byte so we could have up to
    #       7 + 8 = 15 bytes (on a 64-bit platform) for a short string.
    EndOfLineComment: str           # e.g., `# nothing gets passed you`
    MidLineComment: str             # e.g., `#( whatever )#`
    MultilineComment: array[str]    # e.g., `#(# ... #)#` with newlines

    CompilerComment: str    # e.g., `#salt(123)`
    CompilerError: str      # e.g., `#@!$...`

    LowerCamelCase: str
    UpperCamelCase: str

    Indent: i64
    Declaration: oneOf[Readonly: 1, Writable, Fleeting] {
        @alias Temporary: Fleeting
        @Null: 0
    }

    Comma
    NewLine

    BinaryOperator: n64         # e.g., `and`, `<=`, or `+` squished into 8 bytes,
                                # with higher bytes zeroed.
    PrefixUnaryOperator: n64    # e.g., `-` (without a corresponding left operand)
                                # or `++`, squished into 8 bytes.
    PostfixUnaryOperator: n64   # e.g., `?` or `--`, squished into 8 bytes.

    Rune: i32   # something in single quotes, e.g., 'รถ' or '5'
    String: str # something in double quotes
    # TODO: add InterpolatedString

    Aside: array[token]     # e.g., `(...)`
    Brace: array[token]     # e.g., `{...}`
    Bracket: array[token]   # e.g., `[...]`

    LambdaAside: array[token]   # e.g., `$(...)`
    LambdaBrace: array[token]   # e.g., `${...}`
    LambdaBracket: array[token] # e.g., `$[...]`
] {
    @alias MultiLineComment: MultilineComment
}

n64: u64 {
    @Null: 0
}
