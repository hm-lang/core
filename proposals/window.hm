window := {

    ;;l2(fn(L2;): ~t): t
        fn(This L2;)

    @private {
        L2; l2
    }
}

pixels := {
    # Current size of the image.
    ::size(): size2i
    # Tries to resize the image.  Can fail if the new size is too large (OOM)
    # or if the size is invalid (e.g., negative values).
    ;;size(New->Size2i): try~(ok: size2i, uh)

    # Color getter via coordinates.  Can fail if the coordinates are out of bounds (OOB).
    ::[Coordinates2i, fn(Color): ~t]: try~(ok: t, uh)

    # Color setter via coordinates.
    ;;[Coordinates2i, fn(Color;): ~t]: try~(ok: t, uh)

    # Returns the Buffer ID to use for the GPU to draw these pixels.
    # This can be expensive as we upload the entire image from CPU to GPU, if it has changed.
    # TODO: probably should be @protected
    ;;commit(): pixelsId

    # TODO: line-drawing API.  e.g., `;;draw(Line, Color): null`
    #       probably want a pixel-perfect one, plus a thickness based one.

    @private {
        State ;= state~pixelsId CpuOnly

        # The current image size.
        Size; size2i

        # Row-major order, with rows being rows of pixels across the screen left->right,
        # with `Pixels[0]` being the top row and `Pixels[Height - 1]` the bottom row.
        # Invariant: if `State != GpuOnly`,
        # `Pixels[Y] size() == This size() Width` for all `Y` in bounds
        # and `Pixels size() == This size() Height`.
        Pixels[][]; color
    }
}

vertices~data := {
    # Returns the Buffer ID to use for the GPU to draw these pixels
    # TODO: probably should be @protected
    ;;commit(): verticesId

    @private {
        State ;= state~verticesId CpuOnly

        Vertices[]; data
    }
}

@private state~t := oneOf(
    # This object is not represented on the GPU at all.
    CpuOnly
    # This object is not represented on the CPU at all;
    # it is effectively "write-only" to the GPU; CPU cannot get this data back.
    GpuOnly
    # The GPU version of this object is out of sync with the CPU version.
    # The CPU version should sync (may be expensive).
    NeedsCommit: {PreviousCommit: t}
    # The GPU version of this object is in sync with the CPU version.
    Committed: {Commit: t}
)

font := {
    ;;renew(
        # textures that hold all the drawn runes (glyphs)
        @private This NormalGlyphs: texture
        @private This BoldGlyphs: texture
        @private This ItalicGlyphs: texture
        @private This UnderlinedGlyphs: texture
        # vector for each rune in the texture.
        @private This Coordinates[rune]: vector2i
        # size of each glyph in the texture.
        @private This GlyphSize: size2i
    ) := null

    ::draw(String, FontOptions, Coordinates2i, Texture;): null

    # TODO: `;;draw(..., Mask)` for scissor operations
}

fontOptions := {
    GlyphSize; size2i
    Foreground; color
    Background; color
    Style; fontStyle
}

fontStyle := anyOrNoneOf(
    Bold
    Italic
    Underlined
    Inverted # foreground/background color is inverted
    Chaos # add pseudorandom jitter to drawn runes
)

l2 := {
    # font size needs to be constant while we're drawing on
    # this L2 because we won't get consistent offsets if we
    # change size midway through.  if you want to render
    # different font sizes, render into a different l2,
    # or just draw the font directly to the texture.
    GlyphSize: size2i
    FontOptions; omit(from: fontOptions, Field: @symbol(GlyphSize))

    # returns the size of the rectangle in columns (Width) and rows (Height).
    ::size(): size2i
        Size := This Rectangle size()
        {Size Width // GlyphSize Width, Size Height // GlyphSize Height}

    ;;renew(FontOptions: fontOptions, @private This Texture, Rectangle): null
        This GlyphSize = FontOptions GlyphSize
        This FontOptions = omit(From: FontOptions, Field: @symbol(GlyphSize))
        # TODO: offer an option to center This Rectangle in Rectangle
        #       in case GlyphSize is off.
        This Rectangle = {
            X0: Rectangle X0
            Y0: Rectangle Y0
            Width: (Rectangle Width // GlyphSize Width) * GlyphSize Width
            Height: (Rectangle Height // GlyphSize Height) * GlyphSize Height
        }

    # this position tracks along where you are on the l2 (row/column),
    # and will be used for the next draw command as the starting point.
    # the actual coordinates come from this position, the l2 rectangle
    # offset, and the glyph size.
    Position ;= index2i(Column: 0, Row: 0)

    ;;draw(String, Texture;): null

    @private {
        Rectangle: rectangle
    }
}

vector2~t := {X; t, Y; t}
vector2i := vector2~i32
vector2f := vector2~f32

size2~t := {Width; t, Height; t}
size2i := size2~i32
size2f := size2~f32

index2~t := {Column; t, Row; t}
index2i := index2~i32
index2f := index2~f32
